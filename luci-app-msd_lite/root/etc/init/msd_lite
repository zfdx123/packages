#!/bin/sh /etc/rc.common

. /lib/functions/network.sh  # 导入网络相关函数库

START=99                   # 启动优先级
USE_PROCD=1               # 使用 procd 管理进程

NAME="msd_lite"           # 服务名称
PROG="/usr/bin/$NAME"     # 可执行程序路径

CONF="/etc/$NAME/$NAME.conf.sample"  # 模板配置文件路径
CONFDIR="/var/run/$NAME"              # 运行时生成配置文件目录

validate_before_delete() {
    # 检查是否有孤立的进程
    for pidfile in $CONFDIR/*.pid; do
        local instance=$(basename "$pidfile" .pid)
        uci get "msd_lite.$instance" >/dev/null 2>&1 || {
            logger -t "$NAME" "Cleaning orphaned instance $instance"
            stop_instance "$instance"
        }
    done
}

# 添加网络触发器
# 参数：
#   $1 - 配置节(section)名（字符串）
add_interface_triggers() {
	local enabled network
	# 读取配置节中的 enabled，默认1（启用）
	config_get_bool enabled "$1" "enabled" "1"
	# 读取配置节中的 network 字段（网络名称）
	config_get network "$1" "network"
	# 如果 enabled = 1 且 network 非空，则为该 network 添加接口变更触发器
	[ "$enabled" -eq 0 -o -z "$network" ] || procd_add_reload_interface_trigger "$network"
}

# 校验配置节(section)的配置项是否合法
# 参数：
#   $1 - 配置节名称（例如实例名）
#   $2 - 启动函数回调时传递的状态（用于校验结果，1成功0失败）
validate_msd_lite_section() {
	uci_load_validate "$NAME" "instance" "$1" "$2" \
		'enabled:bool:0' \
		'address:string' \
		'interface:string' \
		'network:string' \
		'loglevel:uinteger:0' \
		'threads:uinteger:0' \
		'bind_to_cpu:bool:0' \
		'drop_slow_clients:bool:0' \
		'precache_size:uinteger:4096' \
		'ring_buffer_size:uinteger:1024' \
		'multicast_recv_buffer_size:uinteger:512' \
		'multicast_recv_timeout:uinteger:2' \
		'rejoin_time:uinteger:0'
}

# 启动单个实例
# 参数：
#   $1 - 实例配置节名称
#   $2 - 校验结果（0表示校验失败，非0表示校验通过）
start_instance() {
	local section="$1"
	local seconds="0"

	# 如果校验失败，则记录日志并返回错误
	[ "$2" -eq 0 ] || {
		logger -p daemon.err -t "$NAME" "$section validation failed."
		return 1
	}
	# 读取该实例的 enabled 配置，若为0则不启动
	config_get_bool enabled "$section" "enabled" "1"
	[ "$enabled" -eq 1 ] || return 1

	# 读取网络名称
	config_get network "$section" "network"
	# 若配置了 network，则尝试最多10秒等待对应接口上线
	if [ -n "$network" ]; then
		while [ "$seconds" -le 10 ]; do
			network_flush_cache          # 刷新网络缓存
			network_get_device interface "$network"   # 根据 network 获取接口名
			[ -n "$interface" ] && break              # 接口存在则跳出循环
			seconds=$((seconds + 2))
			sleep 2
		done
	fi

	# 获取 address 配置（绑定地址）
	config_get address "$section" "address"
	# 地址不能为空
	[ -n "$address" ] || return 1

	# 生成绑定地址的 XML 列表
	local addr bindlist
	for addr in $address; do
		bindlist="${bindlist:+$bindlist\\n\\t\\t\\t}<bind><address>$addr</address></bind>"
	done

	# 读取并转换布尔配置为 yes/no
	config_get_bool bind_to_cpu "$section" "bind_to_cpu" 0
	[ "$bind_to_cpu" = "1" ] && bind_to_cpu="yes" || bind_to_cpu="no"

	config_get_bool drop_slow_clients "$section" "drop_slow_clients" 0
	[ "$drop_slow_clients" = "1" ] && drop_slow_clients="yes" || drop_slow_clients="no"

	# 读取其他配置参数
	config_get loglevel "$section" "loglevel" "0"
	config_get threads "$section" "threads" "0"
	config_get precache_size "$section" "precache_size" "4096"
	config_get ring_buffer_size "$section" "ring_buffer_size" "1024"
	config_get multicast_recv_buffer_size "$section" "multicast_recv_buffer_size" "512"
	config_get multicast_recv_timeout "$section" "multicast_recv_timeout" "2"
	config_get rejoin_time "$section" "rejoin_time" "0"

	# 创建配置目录
	mkdir -p "$CONFDIR"
	# 通过模板替换生成具体的配置文件
	sed -e "s,@logLevel@,$loglevel,g" \
	    -e "s,@threadsCountMax@,$threads,g" \
	    -e "s,@fBindToCPU@,$bind_to_cpu,g" \
	    -e "s,@bindList@,$bindlist,g" \
	    -e "s,@ifName@,$interface,g" \
	    -e "s,@fDropSlowClients@,$drop_slow_clients,g" \
	    -e "s,@precache@,$precache_size,g" \
	    -e "s,@ringBufSize@,$ring_buffer_size,g" \
	    -e "s,@rcvBuf@,$multicast_recv_buffer_size,g" \
	    -e "s,@rcvTimeout@,$multicast_recv_timeout,g" \
	    -e "s,@rejoinTime@,$rejoin_time,g" \
		"$CONF" > "$CONFDIR/$section.conf"

	# 使用 procd 启动该实例，方便进程管理
	procd_open_instance "$NAME-$section"
	procd_set_param command "$PROG" -c "$CONFDIR/$section.conf"
	procd_set_param limits core="unlimited"
	procd_set_param limits nofile="1000000 1000000"
	procd_set_param pidfile "$CONFDIR/$section.pid"
	procd_set_param respawn
	procd_set_param stderr 1
	procd_close_instance
}

# 停止单个实例
# 参数：
#   $1 - 实例名称（配置节名称）
stop_instance() {
	local section="$1"
	procd_kill "$NAME-$section"                     # 使用 procd 杀掉该进程实例
	rm -f "$CONFDIR/$section.conf" "$CONFDIR/$section.pid"  # 删除配置和 pid 文件
}

# 获取单个实例状态（用于 LuCI 显示）
# 参数：
#   $1 - 实例名称
status_instance() {
	local section="$1"
	local pidfile="$CONFDIR/$section.pid"

	# 判断 pidfile 是否存在且进程仍存活，返回运行或停止状态
	if [ -f "$pidfile" ] && kill -0 "$(cat "$pidfile" 2>/dev/null)" 2>/dev/null; then
		echo "$section: running"
	else
		echo "$section: stopped"
	fi
}

# 启动服务（启动所有实例）
start_service() {
	config_load "$NAME"                    # 加载配置
	config_foreach validate_msd_lite_section "instance" start_instance  # 校验并启动所有 instance
}

# 停止服务（停止所有实例）
stop_service() {
	config_load "$NAME"
	config_foreach stop_instance "instance"
}

# 重新加载服务
reload_service() {
	stop
	start
}

# 添加服务触发器（网络接口变更触发器和配置变更触发器）
service_triggers() {
	procd_add_validate validate_before_delete  # 新增校验钩子
	procd_add_reload_trigger "$NAME"   # 添加配置文件变更触发器
	config_load "$NAME"
	config_foreach add_interface_triggers "instance"   # 添加网络接口触发器
}
